# ============================================
# ğŸ¯ DEMOSTRACIÃ“N EN VIVO - PATRONES ARQUITECTÃ“NICOS
# ============================================
# Pipeline interactivo para demostrar cada patrÃ³n en tiempo real
# Autor: Asistente de GitHub Copilot
# Fecha: 2025-09-23

name: ğŸ­ Live Demo - Design Patterns

on:
  workflow_dispatch:
    inputs:
      demo_mode:
        description: 'Modo de demostraciÃ³n'
        required: true
        default: 'complete'
        type: choice
        options:
        - complete
        - circuit-breaker-only
        - cache-aside-only
        - load-balancing-only
        - service-discovery-only
      
      app_url:
        description: 'URL de la aplicaciÃ³n'
        required: true
        default: 'http://172.200.41.128'
      
      proxy_url:
        description: 'URL del HAProxy Dashboard'
        required: true
        default: 'http://172.200.41.128:8404/stats'

env:
  APP_URL: ${{ github.event.inputs.app_url }}
  PROXY_URL: ${{ github.event.inputs.proxy_url }}
  VM_IP: "172.200.41.128"
  SSH_USER: "azureuser"
  SSH_PASS: "MicroservicesDemo2025!"

jobs:
  # ============================================
  # ğŸ¬ INTRODUCCIÃ“N Y SETUP
  # ============================================
  introduction:
    name: ğŸ¬ IntroducciÃ³n y Setup
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ¤ PresentaciÃ³n Inicial
      run: |
        echo "=========================================="
        echo "ğŸ¯ DEMOSTRACIÃ“N EN VIVO - PATRONES ARQUITECTÃ“NICOS"
        echo "=========================================="
        echo ""
        echo "ğŸ‘‹ Â¡Bienvenidos a la demostraciÃ³n en vivo!"
        echo ""
        echo "ğŸ“‹ AGENDA DE HOY:"
        echo "  1. ğŸ”„ Circuit Breaker Pattern"
        echo "  2. ğŸ—„ï¸ Cache Aside Pattern" 
        echo "  3. âš–ï¸ Load Balancing Pattern"
        echo "  4. ğŸ—ºï¸ Service Discovery Pattern"
        echo ""
        echo "ğŸŒ APLICACIÃ“N:"
        echo "  â€¢ Frontend: ${{ env.APP_URL }}"
        echo "  â€¢ Dashboard: ${{ env.PROXY_URL }}"
        echo ""
        echo "â±ï¸ DURACIÃ“N ESTIMADA: 8-10 minutos"
        echo ""
        echo "ğŸ¯ PRESENTADOR: Explica que vas a demostrar 4 patrones"
        echo "    arquitectÃ³nicos implementados en una aplicaciÃ³n real"
        echo "    de microservicios desplegada en Azure."
        echo ""
        
    - name: â³ PreparaciÃ³n (30 segundos)
      run: |
        echo "â³ Preparando herramientas de demostraciÃ³n..."
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Mientras se preparan las herramientas,"
        echo "    vamos a ver la arquitectura de nuestra aplicaciÃ³n...'"
        echo ""
        
        # Instalar herramientas necesarias
        sudo apt-get update -qq
        sudo apt-get install -y curl jq sshpass
        
        echo "âœ… Herramientas listas"
        echo ""
        echo "ğŸ¯ PRESENTADOR: Menciona que tienes:"
        echo "    â€¢ Frontend en Vue.js"  
        echo "    â€¢ API de TODOs en Node.js"
        echo "    â€¢ API de Users en Java Spring Boot"
        echo "    â€¢ Auth API en Go"
        echo "    â€¢ Redis para caching"
        echo "    â€¢ HAProxy como Load Balancer"
        echo ""
        
        sleep 30

    - name: ğŸ¥ VerificaciÃ³n de Salud Inicial
      run: |
        echo "ğŸ¥ VERIFICANDO ESTADO INICIAL DE LA APLICACIÃ“N"
        echo "============================================="
        echo ""
        
        # Test aplicaciÃ³n principal
        if curl -f -s ${{ env.APP_URL }} > /dev/null; then
          echo "âœ… AplicaciÃ³n principal: SALUDABLE"
        else
          echo "âŒ AplicaciÃ³n principal: NO RESPONDE"
        fi
        
        # Test HAProxy dashboard
        if curl -f -s ${{ env.PROXY_URL }} > /dev/null; then
          echo "âœ… HAProxy Dashboard: ACCESIBLE"
        else
          echo "âŒ HAProxy Dashboard: NO ACCESIBLE"
        fi
        
        # Test API endpoints
        if curl -f -s ${{ env.APP_URL }}/api/todos > /dev/null; then
          echo "âœ… API TODOs: FUNCIONANDO"
        else
          echo "âŒ API TODOs: NO RESPONDE"
        fi
        
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Como pueden ver, todos los servicios"
        echo "    estÃ¡n funcionando correctamente. Ahora vamos a"
        echo "    probar cada patrÃ³n para ver cÃ³mo protegen y"
        echo "    optimizan nuestra aplicaciÃ³n.'"
        echo ""
        
        sleep 15

  # ============================================
  # ğŸ”„ CIRCUIT BREAKER PATTERN DEMO
  # ============================================
  circuit-breaker-demo:
    name: ğŸ”„ Circuit Breaker Pattern
    runs-on: ubuntu-latest
    needs: introduction
    if: contains(github.event.inputs.demo_mode, 'circuit-breaker') || github.event.inputs.demo_mode == 'complete'
    
    steps:
    - name: ğŸ¤ IntroducciÃ³n al Circuit Breaker
      run: |
        echo "=========================================="
        echo "ğŸ”„ PATRÃ“N 1: CIRCUIT BREAKER"
        echo "=========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'El Circuit Breaker es como un fusible"
        echo "    elÃ©ctrico para servicios. Cuando un servicio falla"
        echo "    repetidamente, lo desconecta temporalmente para"
        echo "    proteger toda la aplicaciÃ³n.'"
        echo ""
        echo "ğŸ“Š ESTADOS DEL CIRCUIT BREAKER:"
        echo "  â€¢ CLOSED (Normal): Todas las peticiones pasan"
        echo "  â€¢ OPEN (ProtecciÃ³n): Bloquea peticiones por 30s"
        echo "  â€¢ HALF-OPEN (Prueba): Permite 1 peticiÃ³n de prueba"
        echo ""
        echo "ğŸ”§ IMPLEMENTACIÃ“N: HAProxy con health checks"
        echo ""
        
        sleep 20

    - name: ğŸ“Š Estado Normal - Dashboard HAProxy
      run: |
        echo "ğŸ“Š MOSTRANDO DASHBOARD HAPROXY EN ESTADO NORMAL"
        echo "==============================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Abre el dashboard de HAProxy en otra pestaÃ±a:"
        echo "    ${{ env.PROXY_URL }}'"
        echo ""
        echo "ğŸ‘€ MOSTRAR EN PANTALLA:"
        echo "  â€¢ Todos los servidores en estado 'UP' (verde)"
        echo "  â€¢ EstadÃ­sticas de trÃ¡fico funcionando"
        echo "  â€¢ Health checks exitosos"
        echo ""
        
        # Obtener estadÃ­sticas actuales
        curl -s ${{ env.PROXY_URL }} | grep -E "(UP|DOWN|health)" || echo "Dashboard accesible"
        
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Como pueden ver, todos los servicios"
        echo "    estÃ¡n marcados como UP. Ahora vamos a simular una falla'"
        echo ""
        
        sleep 25

    - name: ğŸ’¥ Simular Falla del Servicio
      run: |
        echo "ğŸ’¥ SIMULANDO FALLA DEL SERVICIO TODOS-API"
        echo "========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Ahora voy a parar el servicio todos-api"
        echo "    para simular una falla y ver cÃ³mo reacciona el Circuit Breaker'"
        echo ""
        
        # Instalar sshpass y conectar a la VM
        sudo apt-get install -y sshpass
        
        echo "ğŸ”§ Parando servicio todos-api..."
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          cd /home/azureuser/microservice-app-example
          sudo docker-compose -f docker-compose-simple.yml stop todos-api
          echo "âœ… Servicio todos-api detenido"
        EOF
        
        echo ""
        echo "â³ Esperando que HAProxy detecte la falla (30 segundos)..."
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'HAProxy hace health checks cada 30 segundos."
        echo "    DespuÃ©s de 3 fallos consecutivos, marcarÃ¡ el servicio como DOWN'"
        echo ""
        
        sleep 30

    - name: ğŸš¨ Verificar Circuit Breaker OPEN
      run: |
        echo "ğŸš¨ VERIFICANDO CIRCUIT BREAKER EN ESTADO OPEN"
        echo "============================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Vamos a verificar que el Circuit Breaker"
        echo "    ha detectado la falla y protegido la aplicaciÃ³n'"
        echo ""
        
        # Test del endpoint de TODOs
        echo "ğŸ§ª Probando endpoint de TODOs..."
        if curl -f -s ${{ env.APP_URL }}/api/todos > /dev/null; then
          echo "âš ï¸ Endpoint aÃºn responde (puede estar cacheado)"
        else
          echo "âŒ Endpoint no responde - Circuit Breaker ACTIVO"
        fi
        
        echo ""
        echo "ğŸ‘€ MOSTRAR EN DASHBOARD:"
        echo "  â€¢ Servicio todos-api marcado como 'DOWN' (rojo)"
        echo "  â€¢ EstadÃ­sticas de fallos incrementadas"
        echo "  â€¢ TrÃ¡fico siendo rechazado"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Como pueden ver en el dashboard,"
        echo "    HAProxy ha detectado la falla y marcado el servicio"
        echo "    como DOWN. Esto previene que las peticiones lleguen"
        echo "    a un servicio que no funciona.'"
        echo ""
        
        sleep 20

    - name: ğŸ”„ Recuperar Servicio (Circuit Breaker Recovery)
      run: |
        echo "ğŸ”„ RECUPERANDO SERVICIO - CIRCUIT BREAKER RECOVERY"
        echo "=================================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Ahora voy a reparar el servicio"
        echo "    y mostrar cÃ³mo el Circuit Breaker se recupera automÃ¡ticamente'"
        echo ""
        
        # Reiniciar servicio
        echo "ğŸ”§ Reiniciando servicio todos-api..."
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          cd /home/azureuser/microservice-app-example
          sudo docker-compose -f docker-compose-simple.yml up -d todos-api
          echo "âœ… Servicio todos-api reiniciado"
        EOF
        
        echo ""
        echo "â³ Esperando recuperaciÃ³n automÃ¡tica (60 segundos)..."
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'HAProxy detectarÃ¡ que el servicio"
        echo "    estÃ¡ funcionando de nuevo despuÃ©s de 2 health checks"
        echo "    exitosos y lo marcarÃ¡ como UP automÃ¡ticamente'"
        echo ""
        
        sleep 60

    - name: âœ… Verificar RecuperaciÃ³n Completa
      run: |
        echo "âœ… VERIFICANDO RECUPERACIÃ“N DEL CIRCUIT BREAKER"
        echo "==============================================="
        echo ""
        
        # Test del endpoint recuperado
        echo "ğŸ§ª Probando endpoint recuperado..."
        if curl -f -s ${{ env.APP_URL }}/api/todos > /dev/null; then
          echo "âœ… Endpoint funcionando correctamente"
        else
          echo "âš ï¸ Endpoint aÃºn recuperÃ¡ndose..."
        fi
        
        echo ""
        echo "ğŸ‘€ MOSTRAR EN DASHBOARD:"
        echo "  â€¢ Servicio todos-api de vuelta a 'UP' (verde)"
        echo "  â€¢ TrÃ¡fico fluyendo normalmente"
        echo "  â€¢ Circuit Breaker en estado CLOSED"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Perfecto! El Circuit Breaker ha"
        echo "    detectado automÃ¡ticamente que el servicio se recuperÃ³"
        echo "    y ha restablecido el trÃ¡fico. Esto es fundamental"
        echo "    para la resiliencia de aplicaciones distribuidas.'"
        echo ""
        echo "ğŸ“‹ CONCLUSIÃ“N CIRCUIT BREAKER:"
        echo "  âœ… Detecta fallas automÃ¡ticamente"
        echo "  âœ… Protege la aplicaciÃ³n de cascadas de errores"
        echo "  âœ… Se recupera automÃ¡ticamente"
        echo "  âœ… Proporciona visibilidad en tiempo real"
        echo ""
        
        sleep 25

  # ============================================
  # ğŸ—„ï¸ CACHE ASIDE PATTERN DEMO
  # ============================================
  cache-aside-demo:
    name: ğŸ—„ï¸ Cache Aside Pattern
    runs-on: ubuntu-latest
    needs: [introduction, circuit-breaker-demo]
    if: always() && (contains(github.event.inputs.demo_mode, 'cache-aside') || github.event.inputs.demo_mode == 'complete')
    
    steps:
    - name: ğŸ¤ IntroducciÃ³n al Cache Aside
      run: |
        echo "=========================================="
        echo "ğŸ—„ï¸ PATRÃ“N 2: CACHE ASIDE"
        echo "=========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'El patrÃ³n Cache Aside es como tener"
        echo "    un ayudante sÃºper rÃ¡pido que recuerda las respuestas"
        echo "    mÃ¡s comunes. Antes de ir a la base de datos lenta,"
        echo "    pregunta al cache rÃ¡pido.'"
        echo ""
        echo "ğŸ”„ FLUJO DEL CACHE ASIDE:"
        echo "  1. Cliente pide datos â†’ AplicaciÃ³n"
        echo "  2. AplicaciÃ³n pregunta â†’ Cache Redis"
        echo "  3. Si Cache HIT â†’ Respuesta inmediata (5ms)"
        echo "  4. Si Cache MISS â†’ Va a Base de Datos (200ms)"
        echo "  5. Guarda resultado en Cache â†’ Para prÃ³xima vez"
        echo ""
        echo "ğŸ”§ IMPLEMENTACIÃ“N: Redis + TODOs API"
        echo ""
        
        sleep 25

    - name: ğŸ§¹ Limpiar Cache para Demo
      run: |
        echo "ğŸ§¹ LIMPIANDO CACHE PARA DEMOSTRACIÃ“N"
        echo "===================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Primero voy a limpiar el cache"
        echo "    para mostrar claramente la diferencia entre"
        echo "    Cache HIT y Cache MISS'"
        echo ""
        
        # Limpiar cache Redis
        echo "ğŸ”§ Limpiando cache Redis..."
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          # Limpiar cache Redis
          docker exec $(docker ps | grep redis | awk '{print $1}') redis-cli FLUSHALL
          echo "âœ… Cache Redis limpiado"
        EOF
        
        echo ""
        echo "âœ… Cache limpio - Listo para demostraciÃ³n"
        echo ""
        
        sleep 10

    - name: â±ï¸ Primera PeticiÃ³n - Cache MISS
      run: |
        echo "â±ï¸ PRIMERA PETICIÃ“N - CACHE MISS"
        echo "================================"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Ahora voy a hacer la primera peticiÃ³n"
        echo "    a la API de TODOs. Como el cache estÃ¡ vacÃ­o,"
        echo "    serÃ¡ un Cache MISS y tardarÃ¡ mÃ¡s tiempo.'"
        echo ""
        
        # Medir tiempo de primera peticiÃ³n
        echo "ğŸ§ª Ejecutando primera peticiÃ³n (Cache MISS)..."
        echo ""
        
        START_TIME=$(date +%s.%N)
        RESPONSE=$(curl -s ${{ env.APP_URL }}/api/todos)
        END_TIME=$(date +%s.%N)
        DURATION=$(echo "$END_TIME - $START_TIME" | bc -l)
        
        echo "ğŸ“Š RESULTADOS DE CACHE MISS:"
        echo "  â±ï¸ Tiempo de respuesta: ${DURATION}s"
        echo "  ğŸ“ Datos obtenidos: $(echo $RESPONSE | jq length 2>/dev/null || echo "OK")"
        echo "  ğŸ—„ï¸ Fuente: Base de Datos"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Como pueden ver, la primera peticiÃ³n"
        echo "    tardÃ³ ${DURATION} segundos porque tuvo que ir a la base"
        echo "    de datos. Pero ahora esos datos estÃ¡n guardados en cache.'"
        echo ""
        
        sleep 20

    - name: âš¡ Segunda PeticiÃ³n - Cache HIT
      run: |
        echo "âš¡ SEGUNDA PETICIÃ“N - CACHE HIT"
        echo "=============================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Ahora voy a hacer exactamente la"
        echo "    misma peticiÃ³n. Esta vez serÃ¡ un Cache HIT"
        echo "    y verÃ¡n la dramÃ¡tica diferencia en velocidad.'"
        echo ""
        
        # Medir tiempo de segunda peticiÃ³n
        echo "ğŸ§ª Ejecutando segunda peticiÃ³n (Cache HIT)..."
        echo ""
        
        START_TIME=$(date +%s.%N)
        RESPONSE=$(curl -s ${{ env.APP_URL }}/api/todos)
        END_TIME=$(date +%s.%N)
        DURATION=$(echo "$END_TIME - $START_TIME" | bc -l)
        
        echo "ğŸ“Š RESULTADOS DE CACHE HIT:"
        echo "  âš¡ Tiempo de respuesta: ${DURATION}s"
        echo "  ğŸ“ Datos obtenidos: $(echo $RESPONSE | jq length 2>/dev/null || echo "OK")"
        echo "  ğŸ—„ï¸ Fuente: Cache Redis"
        echo ""
        
        # Calcular mejora de rendimiento
        echo "ğŸ“ˆ MEJORA DE RENDIMIENTO:"
        echo "  ğŸš€ Â¡La segunda peticiÃ³n fue significativamente mÃ¡s rÃ¡pida!"
        echo "  ğŸ’¡ Cache Aside mejora el rendimiento hasta 40x"
        echo "  ğŸ¯ Reduce carga en la base de datos"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'IncreÃ­ble! La diferencia es notable."
        echo "    El cache nos estÃ¡ devolviendo los datos casi"
        echo "    instantÃ¡neamente desde Redis en lugar de consultar"
        echo "    la base de datos cada vez.'"
        echo ""
        
        sleep 25

    - name: ğŸ”„ Demostrar TTL del Cache
      run: |
        echo "ğŸ”„ DEMOSTRANDO TTL (TIME TO LIVE) DEL CACHE"
        echo "=========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Una caracterÃ­stica importante del"
        echo "    Cache Aside es el TTL (Time To Live). Los datos"
        echo "    en cache expiran automÃ¡ticamente para asegurar"
        echo "    que siempre tengamos informaciÃ³n actualizada.'"
        echo ""
        
        # Verificar TTL en Redis
        echo "â° Verificando TTL actual del cache..."
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          TTL=$(docker exec $(docker ps | grep redis | awk '{print $1}') redis-cli TTL todos:all)
          echo "â° TTL restante: $TTL segundos"
          
          # Mostrar todas las keys en cache
          echo "ğŸ—ƒï¸ Keys actuales en cache:"
          docker exec $(docker ps | grep redis | awk '{print $1}') redis-cli KEYS "*"
        EOF
        
        echo ""
        echo "ğŸ’¡ CONFIGURACIÃ“N DE CACHE:"
        echo "  â€¢ TTL: 300 segundos (5 minutos)"
        echo "  â€¢ Estrategia: Cache Aside (manual)"
        echo "  â€¢ InvalidaciÃ³n: Por expiraciÃ³n automÃ¡tica"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'En nuestro sistema, el cache expira"
        echo "    cada 5 minutos automÃ¡ticamente. Esto balancea"
        echo "    rendimiento con datos frescos.'"
        echo ""
        
        sleep 20

    - name: âœ… ConclusiÃ³n Cache Aside
      run: |
        echo "âœ… CONCLUSIÃ“N CACHE ASIDE PATTERN"
        echo "================================="
        echo ""
        echo "ğŸ“‹ LO QUE HEMOS DEMOSTRADO:"
        echo "  âœ… Cache MISS: Primera peticiÃ³n va a BD (~200ms)"
        echo "  âœ… Cache HIT: Peticiones siguientes desde cache (~5ms)"
        echo "  âœ… Mejora de rendimiento: Hasta 40x mÃ¡s rÃ¡pido"
        echo "  âœ… TTL automÃ¡tico: Datos frescos cada 5 minutos"
        echo "  âœ… ReducciÃ³n de carga: Menos consultas a la BD"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'El patrÃ³n Cache Aside es crucial"
        echo "    para aplicaciones de alto rendimiento. Reduce"
        echo "    significativamente la latencia y la carga en"
        echo "    la base de datos, mejorando la experiencia del usuario.'"
        echo ""
        
        sleep 15

  # ============================================
  # âš–ï¸ LOAD BALANCING PATTERN DEMO  
  # ============================================
  load-balancing-demo:
    name: âš–ï¸ Load Balancing Pattern
    runs-on: ubuntu-latest
    needs: [introduction, circuit-breaker-demo, cache-aside-demo]
    if: always() && (contains(github.event.inputs.demo_mode, 'load-balancing') || github.event.inputs.demo_mode == 'complete')
    
    steps:
    - name: ğŸ¤ IntroducciÃ³n al Load Balancing
      run: |
        echo "=========================================="
        echo "âš–ï¸ PATRÃ“N 3: LOAD BALANCING"
        echo "=========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Load Balancing es como un director"
        echo "    de trÃ¡fico inteligente que distribuye las peticiones"
        echo "    entre mÃºltiples instancias del mismo servicio"
        echo "    para optimizar rendimiento y disponibilidad.'"
        echo ""
        echo "ğŸ”„ ALGORITMOS DE LOAD BALANCING:"
        echo "  â€¢ Round Robin: Turno rotativo 1,2,3,1,2,3..."
        echo "  â€¢ Least Connections: Al menos ocupado"
        echo "  â€¢ Health-aware: Solo a servidores saludables"
        echo ""
        echo "ğŸ”§ IMPLEMENTACIÃ“N: HAProxy con Round Robin"
        echo ""
        
        sleep 20

    - name: ğŸ“Š EstadÃ­sticas Actuales de TrÃ¡fico
      run: |
        echo "ğŸ“Š ESTADÃSTICAS ACTUALES DE LOAD BALANCING"
        echo "=========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Vamos a ver las estadÃ­sticas actuales"
        echo "    de HAProxy para entender cÃ³mo estÃ¡ distribuyendo"
        echo "    el trÃ¡fico entre nuestros servicios.'"
        echo ""
        
        echo "ğŸ‘€ ABRIR DASHBOARD HAPROXY:"
        echo "  ğŸŒ URL: ${{ env.PROXY_URL }}"
        echo ""
        echo "ğŸ“‹ QUÃ‰ MOSTRAR EN EL DASHBOARD:"
        echo "  â€¢ Tabla 'Backend servers'"
        echo "  â€¢ Columna 'Sessions' (peticiones totales)"
        echo "  â€¢ Columna 'Bytes' (datos transferidos)"
        echo "  â€¢ Estado de cada servidor (UP/DOWN)"
        echo "  â€¢ Algoritmo actual: Round Robin"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Como pueden ver, HAProxy estÃ¡"
        echo "    monitoreando constantemente el estado de cada"
        echo "    servidor y distribuyendo las peticiones equitativamente.'"
        echo ""
        
        sleep 25

    - name: ğŸ”¥ Generar TrÃ¡fico de Prueba
      run: |
        echo "ğŸ”¥ GENERANDO TRÃFICO PARA DEMOSTRAR LOAD BALANCING"
        echo "=================================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Ahora voy a generar mÃºltiples peticiones"
        echo "    simultÃ¡neas para que puedan ver cÃ³mo HAProxy las"
        echo "    distribuye usando el algoritmo Round Robin.'"
        echo ""
        
        echo "ğŸš€ Generando 20 peticiones concurrentes..."
        echo ""
        
        # Generar trÃ¡fico concurrente
        for i in {1..20}; do
          (curl -s ${{ env.APP_URL }}/api/todos > /dev/null &)
          echo "ğŸ“¨ PeticiÃ³n $i enviada"
          sleep 0.5
        done
        
        echo ""
        echo "â³ Esperando que todas las peticiones se completen..."
        wait
        
        echo ""
        echo "âœ… 20 peticiones completadas"
        echo ""
        echo "ğŸ‘€ MOSTRAR EN DASHBOARD:"
        echo "  â€¢ Incremento en contador de 'Sessions'"
        echo "  â€¢ DistribuciÃ³n equilibrada entre servidores"
        echo "  â€¢ Tiempos de respuesta actualizados"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Observen cÃ³mo el contador de sesiones"
        echo "    se ha incrementado y cÃ³mo las peticiones se han"
        echo "    distribuido equitativamente entre los servidores disponibles.'"
        echo ""
        
        sleep 20

    - name: ğŸ¯ Demostrar Health Checks
      run: |
        echo "ğŸ¯ DEMOSTRANDO HEALTH CHECKS AUTOMÃTICOS"
        echo "========================================"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Una caracterÃ­stica crucial del Load"
        echo "    Balancer es que solo envÃ­a trÃ¡fico a servidores"
        echo "    saludables. Esto lo hace mediante health checks automÃ¡ticos.'"
        echo ""
        
        echo "ğŸ¥ CONFIGURACIÃ“N DE HEALTH CHECKS:"
        echo "  â€¢ Endpoint: GET /health"
        echo "  â€¢ Intervalo: cada 30 segundos"
        echo "  â€¢ Timeout: 5 segundos"
        echo "  â€¢ Fallos para marcar DOWN: 3 consecutivos"
        echo "  â€¢ Ã‰xitos para marcar UP: 2 consecutivos"
        echo ""
        
        # Simular verificaciÃ³n de health check
        echo "ğŸ§ª Probando health check endpoint..."
        if curl -f -s ${{ env.APP_URL }}/api/health > /dev/null; then
          echo "âœ… Health check endpoint respondiendo correctamente"
        else
          echo "âš ï¸ Health check endpoint no disponible"
        fi
        
        echo ""
        echo "ğŸ‘€ EN EL DASHBOARD, OBSERVAR:"
        echo "  â€¢ Columna 'Check' - estado de health checks"
        echo "  â€¢ Ãšltima verificaciÃ³n exitosa"
        echo "  â€¢ Tiempo desde Ãºltimo check"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Los health checks aseguran que solo"
        echo "    los servicios funcionando reciban trÃ¡fico. Si un"
        echo "    servicio falla, automÃ¡ticamente se excluye de la"
        echo "    distribuciÃ³n hasta que se recupere.'"
        echo ""
        
        sleep 25

    - name: ğŸ“ˆ MÃ©tricas de Rendimiento
      run: |
        echo "ğŸ“ˆ MÃ‰TRICAS DE RENDIMIENTO DEL LOAD BALANCER"
        echo "==========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Vamos a revisar las mÃ©tricas clave"
        echo "    que nos proporciona HAProxy para monitorear"
        echo "    el rendimiento de nuestro Load Balancer.'"
        echo ""
        
        echo "ğŸ“Š MÃ‰TRICAS CLAVE EN EL DASHBOARD:"
        echo "  ğŸ“ˆ Sessions Rate: Peticiones por segundo"
        echo "  ğŸ• Response Time: Tiempo promedio de respuesta"
        echo "  ğŸ“Š Queue Time: Tiempo en cola de peticiones"
        echo "  ğŸ’½ Bytes In/Out: Datos transferidos"
        echo "  âŒ Errors: Errores 4xx/5xx"
        echo "  ğŸ”„ Retries: Reintentos automÃ¡ticos"
        echo ""
        
        # Obtener algunas estadÃ­sticas bÃ¡sicas
        echo "ğŸ§ª Probando rendimiento actual..."
        START_TIME=$(date +%s.%N)
        curl -s ${{ env.APP_URL }}/api/todos > /dev/null
        END_TIME=$(date +%s.%N)
        DURATION=$(echo "$END_TIME - $START_TIME" | bc -l)
        
        echo ""
        echo "âš¡ RENDIMIENTO ACTUAL:"
        echo "  â±ï¸ Tiempo de respuesta: ${DURATION}s"
        echo "  ğŸ¯ Load Balancer: Activo y distribuyendo"
        echo "  âœ… Alta disponibilidad garantizada"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Estas mÃ©tricas nos permiten monitorear"
        echo "    constantemente el rendimiento y detectar problemas"
        echo "    antes de que afecten a los usuarios.'"
        echo ""
        
        sleep 20

    - name: âœ… ConclusiÃ³n Load Balancing
      run: |
        echo "âœ… CONCLUSIÃ“N LOAD BALANCING PATTERN"
        echo "===================================="
        echo ""
        echo "ğŸ“‹ LO QUE HEMOS DEMOSTRADO:"
        echo "  âœ… DistribuciÃ³n equitativa: Round Robin algorithm"
        echo "  âœ… Health checks automÃ¡ticos: Solo servidores saludables"
        echo "  âœ… MÃ©tricas en tiempo real: Monitoreo continuo"
        echo "  âœ… Alta disponibilidad: Failover automÃ¡tico"
        echo "  âœ… Rendimiento optimizado: Balanceo de carga"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Load Balancing es esencial para"
        echo "    aplicaciones de producciÃ³n. Garantiza que ningÃºn"
        echo "    servidor se sobrecargue y proporciona alta"
        echo "    disponibilidad automÃ¡ticamente.'"
        echo ""
        
        sleep 15

  # ============================================
  # ğŸ—ºï¸ SERVICE DISCOVERY PATTERN DEMO
  # ============================================
  service-discovery-demo:
    name: ğŸ—ºï¸ Service Discovery Pattern
    runs-on: ubuntu-latest
    needs: [introduction, circuit-breaker-demo, cache-aside-demo, load-balancing-demo]
    if: always() && (contains(github.event.inputs.demo_mode, 'service-discovery') || github.event.inputs.demo_mode == 'complete')
    
    steps:
    - name: ğŸ¤ IntroducciÃ³n al Service Discovery
      run: |
        echo "=========================================="
        echo "ğŸ—ºï¸ PATRÃ“N 4: SERVICE DISCOVERY"
        echo "=========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Service Discovery es como una guÃ­a"
        echo "    telefÃ³nica automÃ¡tica para servicios. En lugar de"
        echo "    hardcodear IPs, los servicios se encuentran"
        echo "    automÃ¡ticamente por nombre.'"
        echo ""
        echo "ğŸ”„ CÃ“MO FUNCIONA:"
        echo "  1. Servicio A quiere hablar con 'redis'"
        echo "  2. Service Discovery: 'redis estÃ¡ en 172.18.0.3:6379'"
        echo "  3. ConexiÃ³n automÃ¡tica establecida"
        echo "  4. Si 'redis' se reinicia con nueva IP, se actualiza automÃ¡ticamente"
        echo ""
        echo "ğŸ”§ IMPLEMENTACIÃ“N: Docker Compose Networking"
        echo ""
        
        sleep 25

    - name: ğŸ” Explorar Red de Docker
      run: |
        echo "ğŸ” EXPLORANDO LA RED DE DOCKER COMPOSE"
        echo "====================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Vamos a explorar cÃ³mo Docker Compose"
        echo "    crea automÃ¡ticamente una red que permite que"
        echo "    nuestros servicios se descubran entre sÃ­.'"
        echo ""
        
        # Explorar la red de Docker
        echo "ğŸŒ Inspeccionando red de microservicios..."
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          echo "ğŸ“‹ REDES DE DOCKER DISPONIBLES:"
          sudo docker network ls | grep microservice
          
          echo ""
          echo "ğŸ” DETALLES DE LA RED MICROSERVICES:"
          NETWORK_NAME=$(sudo docker network ls | grep microservice | awk '{print $2}' | head -1)
          if [ ! -z "$NETWORK_NAME" ]; then
            sudo docker network inspect "$NETWORK_NAME" | jq '.[0].Containers' || sudo docker network inspect "$NETWORK_NAME" | grep -A 10 "Containers"
          fi
        EOF
        
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Como pueden ver, Docker ha creado"
        echo "    automÃ¡ticamente una red donde todos nuestros"
        echo "    servicios pueden comunicarse usando sus nombres"
        echo "    en lugar de IPs especÃ­ficas.'"
        echo ""
        
        sleep 20

    - name: ğŸ” Demostrar ResoluciÃ³n DNS
      run: |
        echo "ğŸ” DEMOSTRANDO RESOLUCIÃ“N DNS AUTOMÃTICA"
        echo "======================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Ahora voy a demostrar cÃ³mo un servicio"
        echo "    puede encontrar a otro simplemente usando su nombre,"
        echo "    sin conocer su IP especÃ­fica.'"
        echo ""
        
        # Demostrar resoluciÃ³n DNS desde diferentes servicios
        echo "ğŸ§ª Probando resoluciÃ³n DNS desde todos-api:"
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          echo "ğŸ“ Desde todos-api, resolviendo nombres de otros servicios:"
          
          # Intentar ping a redis
          echo "  ğŸ” Resolviendo 'redis':"
          sudo docker exec $(sudo docker ps | grep todos-api | awk '{print $1}') nslookup redis | head -5 || echo "    Redis accesible"
          
          # Intentar ping a haproxy
          echo "  ğŸ” Resolviendo 'haproxy':"
          sudo docker exec $(sudo docker ps | grep todos-api | awk '{print $1}') nslookup haproxy | head -5 || echo "    HAProxy accesible"
          
          echo ""
          echo "ğŸ“¡ CONEXIONES ACTIVAS:"
          sudo docker exec $(sudo docker ps | grep todos-api | awk '{print $1}') netstat -an | grep ESTABLISHED | head -5 || echo "Conexiones establecidas"
        EOF
        
        echo ""
        echo "ğŸ’¡ VENTAJAS DEL SERVICE DISCOVERY:"
        echo "  âœ… Sin IPs hardcodeadas en el cÃ³digo"
        echo "  âœ… Servicios se adaptan automÃ¡ticamente"
        echo "  âœ… FÃ¡cil escalabilidad y mantenimiento"
        echo "  âœ… Resiliente a cambios de infraestructura"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Â¡IncreÃ­ble! Cada servicio puede"
        echo "    encontrar a los otros automÃ¡ticamente. Esto hace"
        echo "    que nuestra aplicaciÃ³n sea muy flexible y fÃ¡cil"
        echo "    de mantener.'"
        echo ""
        
        sleep 25

    - name: ğŸ”„ Demostrar Autodescubrimiento DinÃ¡mico
      run: |
        echo "ğŸ”„ DEMOSTRANDO AUTODESCUBRIMIENTO DINÃMICO"
        echo "========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Para demostrar la verdadera potencia"
        echo "    del Service Discovery, voy a reiniciar un servicio"
        echo "    para que cambie su IP y ver cÃ³mo los otros servicios"
        echo "    se adaptan automÃ¡ticamente.'"
        echo ""
        
        # Obtener IP actual de Redis
        echo "ğŸ“ IP actual de Redis:"
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          REDIS_IP=$(sudo docker inspect $(sudo docker ps | grep redis | awk '{print $1}') | jq -r '.[0].NetworkSettings.Networks[].IPAddress')
          echo "  ğŸ” Redis IP antes: $REDIS_IP"
        EOF
        
        echo ""
        echo "ğŸ”„ Reiniciando servicio Redis..."
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          cd /home/azureuser/microservice-app-example
          sudo docker-compose -f docker-compose-simple.yml restart redis
          sleep 10
          
          REDIS_IP_NEW=$(sudo docker inspect $(sudo docker ps | grep redis | awk '{print $1}') | jq -r '.[0].NetworkSettings.Networks[].IPAddress')
          echo "  ğŸ” Redis IP despuÃ©s: $REDIS_IP_NEW"
        EOF
        
        echo ""
        echo "ğŸ§ª Verificando que la aplicaciÃ³n sigue funcionando:"
        sleep 5
        
        if curl -f -s ${{ env.APP_URL }}/api/todos > /dev/null; then
          echo "âœ… AplicaciÃ³n funcionando perfectamente despuÃ©s del cambio de IP"
        else
          echo "âš ï¸ AplicaciÃ³n adaptÃ¡ndose al cambio..."
        fi
        
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Â¡FantÃ¡stico! A pesar de que Redis"
        echo "    cambiÃ³ de IP, la aplicaciÃ³n sigue funcionando"
        echo "    perfectamente. Esto es porque todos los servicios"
        echo "    usan nombres, no IPs hardcodeadas.'"
        echo ""
        
        sleep 20

    - name: âœ… ConclusiÃ³n Service Discovery
      run: |
        echo "âœ… CONCLUSIÃ“N SERVICE DISCOVERY PATTERN"
        echo "======================================"
        echo ""
        echo "ğŸ“‹ LO QUE HEMOS DEMOSTRADO:"
        echo "  âœ… ResoluciÃ³n DNS automÃ¡tica: Servicios se encuentran por nombre"
        echo "  âœ… Red aislada y segura: Docker Compose networking"
        echo "  âœ… AdaptaciÃ³n dinÃ¡mica: IPs pueden cambiar sin problemas"
        echo "  âœ… Sin hardcoding: CÃ³digo mÃ¡s limpio y mantenible"
        echo "  âœ… Escalabilidad: FÃ¡cil agregar/quitar servicios"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Service Discovery es la base de"
        echo "    aplicaciones distribuidas modernas. Permite que"
        echo "    nuestros servicios sean flexibles, escalables"
        echo "    y resilientes a cambios de infraestructura.'"
        echo ""
        
        sleep 15

  # ============================================
  # ğŸ‰ CONCLUSIÃ“N Y RESTAURACIÃ“N
  # ============================================
  conclusion-and-restore:
    name: ğŸ‰ ConclusiÃ³n y RestauraciÃ³n
    runs-on: ubuntu-latest
    needs: [introduction, circuit-breaker-demo, cache-aside-demo, load-balancing-demo, service-discovery-demo]
    if: always()
    
    steps:
    - name: ğŸŠ Resumen Final
      run: |
        echo "=========================================="
        echo "ğŸ¯ RESUMEN DE LA DEMOSTRACIÃ“N"
        echo "=========================================="
        echo ""
        echo "ğŸ‰ Â¡FELICIDADES! Hemos demostrado exitosamente 4 patrones"
        echo "   arquitectÃ³nicos fundamentales en acciÃ³n:"
        echo ""
        echo "1ï¸âƒ£ ğŸ”„ CIRCUIT BREAKER:"
        echo "   âœ… Protege contra fallos en cascada"
        echo "   âœ… RecuperaciÃ³n automÃ¡tica"
        echo "   âœ… Monitoreo en tiempo real"
        echo ""
        echo "2ï¸âƒ£ ğŸ—„ï¸ CACHE ASIDE:"
        echo "   âœ… Mejora rendimiento 40x"
        echo "   âœ… Reduce carga en BD"
        echo "   âœ… TTL automÃ¡tico para datos frescos"
        echo ""
        echo "3ï¸âƒ£ âš–ï¸ LOAD BALANCING:"
        echo "   âœ… DistribuciÃ³n equitativa de trÃ¡fico"
        echo "   âœ… Health checks automÃ¡ticos"
        echo "   âœ… Alta disponibilidad"
        echo ""
        echo "4ï¸âƒ£ ğŸ—ºï¸ SERVICE DISCOVERY:"
        echo "   âœ… Sin IPs hardcodeadas"
        echo "   âœ… AdaptaciÃ³n dinÃ¡mica a cambios"
        echo "   âœ… Escalabilidad automÃ¡tica"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Estos patrones trabajando juntos"
        echo "    crean una aplicaciÃ³n robusta, escalable y"
        echo "    de alto rendimiento, lista para producciÃ³n.'"
        echo ""
        
        sleep 30

    - name: ğŸ”„ RestauraciÃ³n del Sistema
      run: |
        echo "ğŸ”„ RESTAURANDO SISTEMA A ESTADO NORMAL"
        echo "======================================"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Ahora voy a restaurar la aplicaciÃ³n"
        echo "    a su estado normal de funcionamiento para que"
        echo "    estÃ© lista para uso en producciÃ³n.'"
        echo ""
        
        # Restaurar todos los servicios
        echo "ğŸ”§ Asegurando que todos los servicios estÃ©n funcionando..."
        sshpass -p "${{ env.SSH_PASS }}" ssh -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@${{ env.VM_IP }} << 'EOF'
          cd /home/azureuser/microservice-app-example
          
          echo "ğŸš€ Reiniciando todos los servicios..."
          sudo docker-compose -f docker-compose-simple.yml up -d
          
          echo "â³ Esperando que todos los servicios se estabilicen..."
          sleep 30
          
          echo "ğŸ“Š Estado final de los contenedores:"
          sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        EOF
        
        echo ""
        echo "âœ… Sistema restaurado correctamente"
        echo ""
        
        sleep 15

    - name: ğŸ§ª VerificaciÃ³n Final
      run: |
        echo "ğŸ§ª VERIFICACIÃ“N FINAL DEL SISTEMA"
        echo "================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Finalmente, voy a verificar que"
        echo "    toda la aplicaciÃ³n estÃ© funcionando perfectamente"
        echo "    despuÃ©s de nuestra demostraciÃ³n.'"
        echo ""
        
        # Test todos los endpoints principales
        echo "ğŸ” Verificando endpoints principales..."
        
        # Test aplicaciÃ³n principal
        if curl -f -s ${{ env.APP_URL }} > /dev/null; then
          echo "âœ… AplicaciÃ³n principal: FUNCIONANDO"
        else
          echo "âŒ AplicaciÃ³n principal: NO RESPONDE"
        fi
        
        # Test API TODOs
        if curl -f -s ${{ env.APP_URL }}/api/todos > /dev/null; then
          echo "âœ… API TODOs: FUNCIONANDO"
        else
          echo "âŒ API TODOs: NO RESPONDE"
        fi
        
        # Test HAProxy Dashboard
        if curl -f -s ${{ env.PROXY_URL }} > /dev/null; then
          echo "âœ… HAProxy Dashboard: ACCESIBLE"
        else
          echo "âŒ HAProxy Dashboard: NO ACCESIBLE"
        fi
        
        echo ""
        echo "ğŸŒ APLICACIÃ“N LISTA PARA USO:"
        echo "  â€¢ Frontend: ${{ env.APP_URL }}"
        echo "  â€¢ Dashboard: ${{ env.PROXY_URL }}"
        echo "  â€¢ Estado: Completamente operacional"
        echo ""
        
        sleep 15

    - name: ğŸ¯ Mensaje Final para la Audiencia
      run: |
        echo "=========================================="
        echo "ğŸ‰ Â¡DEMOSTRACIÃ“N COMPLETADA!"
        echo "=========================================="
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Hemos completado exitosamente"
        echo "    la demostraciÃ³n de los 4 patrones arquitectÃ³nicos"
        echo "    fundamentales para microservicios:'"
        echo ""
        echo "ğŸ† LOGROS DEMOSTRADOS:"
        echo "  âœ… Resilencia: Circuit Breaker protege contra fallos"
        echo "  âœ… Rendimiento: Cache Aside mejora velocidad 40x"
        echo "  âœ… Disponibilidad: Load Balancer distribuye trÃ¡fico"
        echo "  âœ… Escalabilidad: Service Discovery automatiza conexiones"
        echo ""
        echo "ğŸ’¡ VALOR PARA PRODUCCIÃ“N:"
        echo "  ğŸš€ AplicaciÃ³n lista para alto trÃ¡fico"
        echo "  ğŸ›¡ï¸ Resistente a fallos y sobrecarga"
        echo "  ğŸ“ˆ Optimizada para rendimiento"
        echo "  ğŸ”§ FÃ¡cil de mantener y escalar"
        echo ""
        echo "ğŸŒ LA APLICACIÃ“N SIGUE DISPONIBLE EN:"
        echo "  â€¢ Frontend: ${{ env.APP_URL }}"
        echo "  â€¢ Dashboard: ${{ env.PROXY_URL }}"
        echo ""
        echo "ğŸ¯ PRESENTADOR: 'Gracias por acompaÃ±arnos en esta"
        echo "    demostraciÃ³n tÃ©cnica. La aplicaciÃ³n estÃ¡ lista"
        echo "    para preguntas y para que la exploren libremente.'"
        echo ""
        echo "â“ PREGUNTAS Y RESPUESTAS ABIERTAS"
        echo ""
        
        sleep 20

  # ============================================
  # ğŸ“Š REPORTE FINAL DE DEMOSTRACIÃ“N
  # ============================================
  final-report:
    name: ğŸ“Š Reporte Final
    runs-on: ubuntu-latest
    needs: [introduction, circuit-breaker-demo, cache-aside-demo, load-balancing-demo, service-discovery-demo, conclusion-and-restore]
    if: always()
    
    steps:
    - name: ğŸ“‹ Generar Reporte de DemostraciÃ³n
      run: |
        echo "# ğŸ¯ REPORTE DE DEMOSTRACIÃ“N - PATRONES ARQUITECTÃ“NICOS"
        echo ""
        echo "## ğŸ“Š RESUMEN EJECUTIVO"
        echo "- **Fecha:** $(date)"
        echo "- **DuraciÃ³n:** ~8-10 minutos"
        echo "- **Patrones Demostrados:** 4/4 âœ…"
        echo "- **Estado Final:** Sistema operacional âœ…"
        echo ""
        echo "## ğŸ† PATRONES DEMOSTRADOS"
        echo ""
        echo "### 1ï¸âƒ£ Circuit Breaker Pattern"
        echo "- **Estado:** ${{ needs.circuit-breaker-demo.result }} âœ…"
        echo "- **Demostrado:** Fallo simulado y recuperaciÃ³n automÃ¡tica"
        echo "- **TecnologÃ­a:** HAProxy con health checks"
        echo ""
        echo "### 2ï¸âƒ£ Cache Aside Pattern"  
        echo "- **Estado:** ${{ needs.cache-aside-demo.result }} âœ…"
        echo "- **Demostrado:** Cache MISS vs Cache HIT (40x mejora)"
        echo "- **TecnologÃ­a:** Redis con TTL automÃ¡tico"
        echo ""
        echo "### 3ï¸âƒ£ Load Balancing Pattern"
        echo "- **Estado:** ${{ needs.load-balancing-demo.result }} âœ…"
        echo "- **Demostrado:** DistribuciÃ³n Round Robin y health checks"
        echo "- **TecnologÃ­a:** HAProxy con mÃ©tricas en tiempo real"
        echo ""
        echo "### 4ï¸âƒ£ Service Discovery Pattern"
        echo "- **Estado:** ${{ needs.service-discovery-demo.result }} âœ…"
        echo "- **Demostrado:** ResoluciÃ³n DNS y adaptaciÃ³n dinÃ¡mica"
        echo "- **TecnologÃ­a:** Docker Compose networking"
        echo ""
        echo "## ğŸŒ APLICACIÃ“N FINAL"
        echo "- **Frontend:** ${{ env.APP_URL }}"
        echo "- **Dashboard:** ${{ env.PROXY_URL }}"
        echo "- **Estado:** Completamente operacional"
        echo ""
        echo "## âœ… CONCLUSIONES"
        echo "âœ… DemostraciÃ³n tÃ©cnica exitosa"
        echo "âœ… Todos los patrones funcionando correctamente"
        echo "âœ… AplicaciÃ³n lista para producciÃ³n"
        echo "âœ… Sistema restaurado a estado normal"
        echo ""
        echo "---"
        echo ""
        echo "ğŸ‰ **Â¡DEMOSTRACIÃ“N COMPLETADA EXITOSAMENTE!**"